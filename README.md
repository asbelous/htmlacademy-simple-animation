# Туториал. Простая анимация на чистом CSS

Мы привыкли использовать CSS по его прямому назначению — для построения сеток и стилизации интерфейсов. И это, бесспорно, основная задача. Но в этом туториале мы рассмотрим, как ещё можно использовать CSS — для создания и анимирования элементов. Чтобы понимать происходящее, достаточно владеть HTML и CSS на базовом уровне.

Будем делать [такое дерево](https://codepen.io/sasha-sm/pen/VwLMQdK):

## Создание дерева

### 1. Разметка

Начнём всё же с HTML, без него никак. Нам понадобится создать простую разметку для описания будущего дерева.

Рисуют обычно на холсте, и нам он тоже понадобится, поэтому для начала создадим блок `.canvas`. Внутри этого блока будет находиться непосредственно дерево `.tree`. У дерева будет ствол `.trunk` и несколько веток — элементы с классом `.branch`. По сути ветви — это части ствола, и мы отразим это в разметке, сделав их дочерними элементами блока `.trunk`. То же самое с листьями — элементы `.leaf` будут вложены в родительский элемент своей ветки.

Вот так выглядит фрагмент разметки дерева с одной веткой, остальные — по аналогии:

```
div class="canvas">
  <div class="tree">
    <div class="trunk">
      <div class="branch">
        <div class="leaf"></div>
        <div class="leaf"></div>
        <div class="leaf"></div>
      </div>
    </div>
  </div>
</div>
```

Конечно, пока это просто несколько пустых блоков, но каркас мы уже сформировали. Двигаемся дальше.

### 2. Подготовка

Переходим к CSS. Для начала нужно спозиционировать наше будущее дерево на холсте. Сделаем `.canvas` флекс-контейнером и выровняем вложенный элемент `.tree` по центру. Также определим размеры холста и зададим ему фоновый цвет.

```
.canvas {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  min-height: 600px;

  background-color: #d1cee0;
}
```

Возможно, вы пока не знакомы с [флексбоксами](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox), но это не страшно. Сейчас мы используем их только чтобы отцентровать элемент. Если будет интересно, [интерактивный курс про флексбоксы](https://htmlacademy.ru/courses/96) поможет разобраться в теме.

### 3. Рисуем ствол и ветки

Всё, теперь мы точно добрались до рисования.

И ствол, и ветки будут одинакового цвета и формы, поэтому сразу объединим все CSS-свойства, с помощью которых добьёмся нужного эффекта. Цвет зададим с помощью [градиента](https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient), чтобы элементы казались менее плоскими, а ещё добавим небольшое скругление на концах веток и ствола. Так будет выглядеть код:

```
.trunk,
.branch {
  border-radius: 25px;
  background: linear-gradient(to right, #7f3333, #4d2020);
}
```

Чтобы элементы, наконец, отобразились, нужно задать им размеры. Ствол сделаем шириной `10px`, а ветки в два раза тоньше — по `5px`. Плюс зададим стволу высоту и выровняем его по центру. На следующем шаге мы будем распределять ветки по своим местам на стволе дерева, а для этого нужно задать стволу относительное позиционирование, а веткам — абсолютное. Это позволит задавать положение каждой конкретной ветки относительно ствола свойствами `top`, `right`, `bottom`, `left` и имитировать рост веток.

```
trunk {
  position: relative;
  
  width: 10px;
  height: 500px;
  margin: 0 auto;
}

.branch {
  position: absolute;
  
  width: 5px;
}
```

### 4. Ставим ветки на место

Пришло время нашей заготовке превратиться в то, что действительно будет похоже на дерево.

1. Для начала часть веток должна быть слева, а другая — справа. Мы будем выбирать нужные ветки с помощью селектора `nth-child(even)` — для чётных элементов и `nth-child(odd)` — для нечётный, а затем вращать их с помощью [свойства `transform`](https://developer.mozilla.org/ru/docs/Web/CSS/transform) и функции `rotate` на 60 градусов влево и вправо.

```
.branch:nth-child(even) {
  transform: rotate(60deg);
}

.branch:nth-child(odd) {
  transform: rotate(-60deg);
}
```
Здесь есть одна тонкость. По умолчанию элемент вращается относительно своего центра, а это не то поведение, которое нам нужно от веток. Они должны вращаться относительно нижней точки элемента — места прикрепления к стволу. И есть хорошая новость — мы можем переопределить поведение по умолчанию, используя свойство `transform-origin` с подходящим значением, тогда ветки будут вращаться относительно своей нижней точки, а не вокруг центра. Добавим элементу `.branch` нужное свойство в дополнение к уже существующим:

```
.branch {
  position: absolute;
  
  width: 5px;
  
  transform-origin: bottom center;
}
```
Чтобы лучше понять, как работает свойство `transform-origin`, посмотрите [эту демку](https://codepen.io/shshaw/pen/pOVKjb).

2. Теперь нам нужно учесть, что ветки расположены несколькими ярусами, и их длина становится тем меньше, чем ближе к верхушке дерева они растут. Укажем для каждой ветки расстояние от верхушки и её длину. Ниже фрагмент кода для первых трёх веток, а дальше зададим значения для остальных веток по аналогии:

```
.branch:nth-child(1) {
  top: 180px;
  
  height: 180px;
}

.branch:nth-child(2) {
  top: 160px;

  height: 150px;
}

.branch:nth-child(3) {
  top: 120px;
  
  height: 150px;
}
```
### 5. Рисуем листья

Как видите, мы соблюдаем логику, заложенную природой — ветки выросли из ствола, а листья будут расти из веток. Листья — дочерние элементы, поэтому снова позиционируем их относительно родительского элемента `.branch`.

```
.leaf {
  position: absolute;
  
  width: 15px;
  height: 15px;
  
  border-radius: 75% 0 75% 0;
  background: linear-gradient(to right, #77ed9e, #53ad71);
}
```

Ещё добавили листикам размер и цвет с помощью градиента, а также закруглили края. Осталось расположить каждый ряд на своём уровне, задав свойство `top` с соответствующими значениями. Вот код для первых двух рядов:

```
.leaf:nth-child(1) {
  top: 5px;
}

.leaf:nth-child(2) {
  top: 20px;
}
```

На этом с созданием дерева мы закончили, осталось только разместить листочки на своих местах и, наконец, добавить анимацию.